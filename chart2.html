<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>

    <!-- ADD Libraries-->
    <script src="libs/d3/d3.min.js" charset="utf-8"></script>
    <script src="http://d3js.org/topojson.v1.min.js"></script>

<style>
body { 
    font: 10px sans-serif; 
} 
.axis text {
    font: 10px sans-serif;
}

.axis line,
.axis path {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
}
#waterVis{

    float:left;
}
#bayVis{

    float:left;
}
#oysterVis{

    float:left;
}
</style>

</head>
<body>
    <div><text id="selectedYear"></text>
    <div>
        <label><input class="measure" type="radio" name="measure" value="tn" checked>Nitrogen</label>
        <label><input class="measure" type="radio" name="measure" value="tp" >Phosphorous</label>
        <label><input class="measure" type="radio" name="measure" value="do" >Dissolved Oxygen</label>
        <label><input class="measure" type="radio" name="measure" value="salinity" >Salinity</label>
        <label><input class="measure" type="radio" name="measure" value="wtemp" >Water Temp</label>

    </div>
    <div id="waterVis"></div>
    <div width=600 id="bayVis"></div>
    <div width=400 id="oysterVis"></div>
    <script>
    var margin = {top:20, right:20, bottom:30, left:80};
    var width = 600 - margin.left - margin.right;
    var height = 700 - margin.top - margin.bottom;
    var padding = 10;

    var selectedYear = 1995;  //year selected by user - will make this interactive

    d3.select("#selectedYear").text("Chesapeake Bay Water Quality - " + selectedYear).style("font-size", "18px");

    var svg = d3.select("#bayVis").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + this.margin.top + margin.bottom);

    var projection = d3.geo.mercator().scale(10000)//scale(15000)
        .center([-76.3,38.5]);//.center([-75.5,39]);

    var path = d3.geo.path()
        .projection(projection);


        d3.json("data/shapefile/chesapeaketopo4.json", function(chesapeake) {
            console.log(chesapeake);

            var topo = topojson.feature(chesapeake, chesapeake.objects.shore_dd);
            console.log(topo.features);

            svg.selectAll("path")
                .data(topo.features)
                .enter()
                .append("path")
                .attr("d", path)
                .style("fill", "lightblue");

        });
        
    d3.csv("data/StationInfoRefined.csv", function(error, data){
            projection.scale(1);
            data = data.map(function(d) {
                var station = d.Station;
                var description = d.Station_Description;
                var fips = d.FIPS;
                var county = d.County_City;
                var lat = d.Latitude;
                var lon = d.Longitude;

                return {
                    "station": station,
                    "description": description,
                    "fips": fips,
                    "county": county,
                    "lat": lat,
                    "lon": lon
                }
            });

        var yScale = d3.scale.linear()
            .domain([d3.min(data, function(d) { return d.lat; }), d3.max(data, function(d) { return d.lat; })])
                .range([595, 15]);
        var xScale = d3.scale.linear()
            .domain([d3.max(data, function(d) { return d.lon; }), d3.min(data, function(d) { return d.lon; })])
            .range([440, 540]);

        var node = svg.selectAll(".station")
            .data(data)
            .enter()
            .append("g").attr("class", "station");
        
        node.append("circle")
            .attr("r", 5)
            .style("cursor", "pointer")
            .on("mouseover", function() {
                    d3.select(this).attr("fill", "red");})
            .on("mouseout", function() {
                    d3.select(this).attr("fill", "black");})
            .on("click", function(d) { return alert("clicking here will display graph for " + d.station);})
            .append("svg:title")
                .text(function(d) { return "lat:" + d.lat + ", lon:" + d.lon;});
        
        node.append("text")
            .text(function(d) {return d.station;})
            .attr("x", function() {return 8;})
            .attr("y", function() {return 3;})
            .attr("transform", function() {
                return "rotate(-35)" 
            });

        node.transition().duration(500)
            .attr("transform", function(d) { 
                return "translate("+xScale(d.lon)+","+yScale(d.lat)+")"; 
            });
    });

    d3.csv("data/OysterCrabLandings.csv", function(error, oysters) {

        landings = oysters.map(function(d) {
            var res = {
                year: parseInt(d.Year),
                pounds: parseInt(d.Pounds),
                value: parseInt(d.Value),
                state: d.State,
                species: d.Species
            }
            return res;
        });

        var margin2 = {top:20, right:20, bottom:30, left:80};
        var width2 = 450 - margin2.left - margin2.right;
        var height2 = 250 - margin2.top - margin2.bottom;
        var padding2 = 10;

        var oystermd = landings.filter(function(d) { return d.species == "Oyster" && d.state == "Maryland";});

        var xScale2 = d3.scale.linear().range([0, width2])
            .domain([1929, 2013]);
        var yScale2 = d3.scale.linear()
            .range([height2, 10])
            .domain([0, d3.max(oystermd, function(d) { return d.pounds; })]);

        var svg2 = d3.select("#oysterVis").append("svg")
            .attr("width", width2 + margin2.left + margin2.right)
            .attr("height", height2 + margin2.top + margin2.bottom)
        .append("g")
            .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

        svg2.append("text").text("Oyster Landings by Year").attr("x", 100).attr("y", 0).style("font", "12px sans-serif");

        var point = svg2.selectAll(".point")
            .data(oystermd)
            .enter()
            .append("g").attr("class", "point");
   
        var xAxis2 = d3.svg.axis()
            .scale(xScale2)
            .orient("bottom")
            .tickFormat(d3.format("d"));

        var yAxis2 = d3.svg.axis()
            .scale(yScale2)
            .orient("left");  

        var sizescale = d3.scale.linear().range([2,20])
            .domain([d3.min(landings, function(d) {return d.value;}), d3.max(landings, function(d) {return d.value;})]);

        point.append("circle")
            .style("fill", function(d) { if (d.state == "Maryland") {return "blue";} else {return "red";}})
            .style("opacity", .8)
            .attr("cx", function(d){return xScale2(d.year);})
            .attr("cy", function(d) {return yScale2(d.pounds);})
            .attr("r", 4)//function(d) {return sizescale(d.value);})
            .append("svg:title")
                .text(function(d){ return "year " + d.year + " pounds " + d.pounds + " value " + d.value + " state " + d.state + " species " + d.species;});
 
        svg2.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height2 + ")")
            .call(xAxis2); ;

        svg2.append("g")
            .attr("class", "y axis")
            .attr("id", "yaxis")
            .call(yAxis2);

        svg2.append("line")
            .attr("x1", xScale2(selectedYear))  
            .attr("y1", 0)
            .attr("x2", xScale2(selectedYear))  
            .attr("y2", height2)
            .style("stroke-width", 1)
            .style("stroke", "red")
            .style("fill", "none");

    });

    d3.csv("data/waterQuality2014.csv", function(error, water) {
        var measure = "TN";
        var layer = "B";

        var data = d3.nest()
            .key(function(d) {return d.month;})
            .rollup(function(leaves) {return [
                d3.mean(leaves, function(d) {return parseFloat(d.MeasureValue);})
            ]})
            .entries(water);
console.log(data);
    });

    var margin = {top:20, right:20, bottom:30, left:80};
    var width = 600 - margin.left - margin.right;
    var height = 1000 - margin.top - margin.bottom;
    var padding = 10;

    var svg = d3.select("#bayVis").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + this.margin.top + margin.bottom);

    var projection = d3.geo.mercator().scale(15000)
        .center([-75.5,39]);
//    .translate([width/2, height/2]);
//    .translate([75, -39])
//    .scale(5000);
//    .scale(5000);
//    .translate([width / 2, height / 2]);
//var projection = d3.geo.albers();

    var path = d3.geo.path()
        .projection(projection);


        d3.json("data/shapefile/chesapeaketopo4.json", function(chesapeake) {
            console.log(chesapeake);
            var topo = topojson.feature(chesapeake, chesapeake.objects.shore_dd);
            console.log(topo.features);

            svg.selectAll("path")
                .data(topo.features)
                .enter()
                .append("path")
                .attr("d", path)
                .style("fill", "lightblue");
        });
        
    d3.csv("data/StationInfoRefined.csv", function(error, data){
 //           projection.scale(1);
            data = data.map(function(d) {
                var station = d.Station;
                var description = d.Station_Description;
                var fips = d.FIPS;
                var county = d.County_City;
                var lat = d.Latitude;
                var lon = d.Longitude;

                return {
                    "station": station,
                    "description": description,
                    "fips": fips,
                    "county": county,
                    "lat": lat,
                    "lon": lon
                }
            });

        var yScale = d3.scale.linear()
            .domain([d3.min(data, function(d) { return d.lat; }), d3.max(data, function(d) { return d.lat; })])
                .range([935, 65]);
        var xScale = d3.scale.linear()
            .domain([d3.max(data, function(d) { return d.lon; }), d3.min(data, function(d) { return d.lon; })])
            .range([228, 358]);

        var node = svg.selectAll(".station")
            .data(data)
            .enter()
            .append("g").attr("class", "station");
        
        node.append("circle")
            .attr("r", 5)
            .append("svg:title")
                .text(function(d) { return "lat:" + d.lat + "," + xScale(d.lat) + " lon:" + d.lon + "," + xScale(d.lon);});
        
        node.append("text")
            .text(function(d) {return d.station;})
            .attr("x", function() {return 8;})
            .attr("y", function() {return 3;});

        node.transition().duration(500)
            .attr("transform", function(d) { 
                return "translate("+xScale(d.lon)+","+yScale(d.lat)+")"; 
            });
    });

    d3.csv("data/OysterCrabLandings.csv", function(error, oysters) {

        landings = oysters.map(function(d) {
            var res = {
                year: parseInt(d.Year),
                pounds: parseInt(d.Pounds),
                value: parseInt(d.Value),
                state: d.State,
                species: d.Species
            }
            return res;
        });

        var margin2 = {top:20, right:20, bottom:30, left:80};
        var width2 = 600 - margin2.left - margin2.right;
        var height2 = 400 - margin2.top - margin2.bottom;
        var padding2 = 10;

        var xScale2 = d3.scale.linear().range([0, width2])
            .domain([1929, 2013]);
        var yScale2 = d3.scale.pow()
            .exponent(1)
            .range([height2, 0])
            .domain([0, d3.max(landings, function(d) { return d.pounds; })]);;

        var svg2 = d3.select("#oysterVis").append("svg")
            .attr("width", width2 + margin2.left + margin2.right)
            .attr("height", height2 + margin2.top + margin2.bottom)
        .append("g")
            .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

        var point = svg2.selectAll(".point")
            .data(landings)
            .enter()
            .append("g").attr("class", "point")
            .filter(function(d) { return d.species == "Oyster" && d.state == "Maryland";});
   
        var xAxis2 = d3.svg.axis()
            .scale(xScale2)
            .orient("bottom");

        var yAxis2 = d3.svg.axis()
            .scale(yScale2)
            .orient("left");  

        var sizescale = d3.scale.linear().range([2,20])
            .domain([d3.min(landings, function(d) {return d.value;}), d3.max(landings, function(d) {return d.value;})]);

        point.append("circle")
            .style("fill", function(d) { if (d.state == "Maryland") {return "blue";} else {return "red";}})
            .style("opacity", .8)
            .attr("cx", function(d){return xScale2(d.year);})
            .attr("cy", function(d) {return yScale2(d.pounds);})
            .attr("r", 4)//function(d) {return sizescale(d.value);})
            .append("svg:title")
                .text(function(d){ return "year " + d.year + " pounds " + d.pounds + " value " + d.value + " state " + d.state + " species " + d.species;});
 
        svg2.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height2 + ")")
            .call(xAxis2); ;

        svg2.append("g")
            .attr("class", "y axis")
            .attr("id", "yaxis")
            .call(yAxis2);

    });



        $(function(){

            var waterQualityData = [];
            var stationInfoData = [];
            var landingsData = [];
            var topoData;

            var initVis = function(){

                var EventHandler = new Object();
  

            } 

            // call this function after both files are loaded -- error should be "null" if no error
            var dataLoaded = function (error, _waterQuality, _stationInfo, _landings, _topomap) {

                if (!error) {

                    landingsData = _landings.map(function(d) {
                        var res = {
                            year: parseInt(d.Year),
                            pounds: parseInt(d.Pounds),
                            value: parseInt(d.Value),
                            state: d.State,
                            species: d.Species
                        }

                        return res;

                    });

                    stationInfoData = _stationInfo.map(function(d) {
                        var res = {
                            station: d.Station,
                            description: d.Station_Description,
                            fips: d.FIPS,
                            county: d.County_City,
                            lat: d.Latitude,
                            lon: d.Longitude
                        }

                        return res;
                    });

                    waterQualityData = _waterQuality.map(function(d) {
                        var res = {
                            station: d.Station,
                            month: d.Month,
                            year: d.Year,
                            depth: d.Total_Depth,
                            mlayer: d.Layer,
                            parameter: d.Parameter,
                            mvalue: d.MeasureValue,
                            unit: d.Unit,
                            lat: d.Lat,
                            lon: d.Lon
                        }
                        return res;
                    });

                    topoData = _topomap;

                    initVis(); 
                }
            }

            var startHere = function(){

                //TODO: load data here and call "dataLoaded" afterwards
                // Hint: http://giscollective.org/d3-queue-js/
                queue()
                    .defer(d3.csv, 'data/waterQuality2014.csv')
                    .defer(d3.csv, 'data/StationInfoRefined.csv')
                    .defer(d3.csv, 'data/OysterCrabLandings.csv')
                    .defer(d3.json, 'data/shapefile/chesapeaketopo4.json')
                    .await(function(error, waterQuality, stationInfo, landings, topomap) {
                        dataLoaded(error, waterQuality, stationInfo, landings, topomap);
                    });
            }

            startHere();
        })
    </script>
</body>
</html>